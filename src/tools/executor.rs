//! Tool executor trait and context
//!
//! Defines the interface for executing GitLab MCP tools.

use crate::access_control::AccessResolver;
use crate::dashboard::DashboardMetrics;
use crate::error::ToolError;
use crate::gitlab::GitLabClient;
use async_trait::async_trait;
use serde_json::Value;
use std::sync::Arc;

/// Context provided to tools during execution
pub struct ToolContext {
    /// GitLab API client
    pub gitlab: Arc<GitLabClient>,
    /// Access control resolver
    pub access: Arc<AccessResolver>,
    /// Unique request ID for tracing
    pub request_id: String,
    /// Dashboard metrics collector (optional)
    pub metrics: Option<Arc<DashboardMetrics>>,
}

impl ToolContext {
    /// Create a new tool context
    pub fn new(
        gitlab: Arc<GitLabClient>,
        access: Arc<AccessResolver>,
        request_id: impl Into<String>,
    ) -> Self {
        Self {
            gitlab,
            access,
            request_id: request_id.into(),
            metrics: None,
        }
    }

    /// Create a new tool context with metrics
    pub fn with_metrics(
        gitlab: Arc<GitLabClient>,
        access: Arc<AccessResolver>,
        request_id: impl Into<String>,
        metrics: Arc<DashboardMetrics>,
    ) -> Self {
        Self {
            gitlab,
            access,
            request_id: request_id.into(),
            metrics: Some(metrics),
        }
    }
}

/// Result of tool execution
#[derive(Debug, Clone)]
pub struct ToolOutput {
    /// Content blocks to return
    pub content: Vec<ContentBlock>,
    /// Whether this result represents an error
    pub is_error: bool,
}

impl ToolOutput {
    /// Create a successful text result
    pub fn text(text: impl Into<String>) -> Self {
        Self {
            content: vec![ContentBlock::Text { text: text.into() }],
            is_error: false,
        }
    }

    /// Create a successful JSON result
    pub fn json(value: impl serde::Serialize) -> Result<Self, ToolError> {
        let json = serde_json::to_string_pretty(&value)?;
        Ok(Self {
            content: vec![ContentBlock::Text { text: json }],
            is_error: false,
        })
    }

    /// Create a successful result with raw JSON value
    pub fn json_value(value: Value) -> Result<Self, ToolError> {
        let json = serde_json::to_string_pretty(&value)?;
        Ok(Self {
            content: vec![ContentBlock::Text { text: json }],
            is_error: false,
        })
    }

    /// Create an error result
    pub fn error(message: impl Into<String>) -> Self {
        Self {
            content: vec![ContentBlock::Text {
                text: message.into(),
            }],
            is_error: true,
        }
    }

    /// Create a result with multiple content blocks
    pub fn multi(content: Vec<ContentBlock>, is_error: bool) -> Self {
        Self { content, is_error }
    }
}

/// Content block types
#[derive(Debug, Clone)]
pub enum ContentBlock {
    /// Text content
    Text { text: String },
    /// Image content (base64 encoded)
    Image { data: String, mime_type: String },
    /// Resource reference
    Resource {
        uri: String,
        mime_type: Option<String>,
        text: Option<String>,
    },
}

/// Trait for tool executors
///
/// This trait is implemented by each tool struct to provide the execution logic.
/// The `#[gitlab_tool]` macro generates the boilerplate (schema, registration, etc.)
/// but you implement this trait for the actual execution.
#[async_trait]
pub trait ToolExecutor: Send + Sync {
    /// Execute the tool with the given context
    ///
    /// The tool has access to:
    /// - `self` - The parsed arguments
    /// - `ctx.gitlab` - GitLab API client
    /// - `ctx.access` - Access control (already checked before execution)
    /// - `ctx.request_id` - Request ID for tracing
    async fn execute(&self, ctx: &ToolContext) -> Result<ToolOutput, ToolError>;
}

/// Static tool information (generated by macro)
pub trait ToolInfo {
    /// Get the tool name
    fn name() -> &'static str;

    /// Get the tool description
    fn description() -> &'static str;

    /// Get the tool category
    fn category() -> crate::access_control::ToolCategory;

    /// Get the operation type
    fn operation_type() -> crate::access_control::OperationType;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tool_output_text() {
        let output = ToolOutput::text("Hello, world!");
        assert!(!output.is_error);
        assert_eq!(output.content.len(), 1);
        match &output.content[0] {
            ContentBlock::Text { text } => assert_eq!(text, "Hello, world!"),
            _ => panic!("Expected text content"),
        }
    }

    #[test]
    fn test_tool_output_json() {
        let data = serde_json::json!({"id": 42, "name": "test"});
        let output = ToolOutput::json(&data).unwrap();
        assert!(!output.is_error);
        match &output.content[0] {
            ContentBlock::Text { text } => {
                assert!(text.contains("\"id\": 42"));
                assert!(text.contains("\"name\": \"test\""));
            }
            _ => panic!("Expected text content"),
        }
    }

    #[test]
    fn test_tool_output_error() {
        let output = ToolOutput::error("Something went wrong");
        assert!(output.is_error);
        match &output.content[0] {
            ContentBlock::Text { text } => assert_eq!(text, "Something went wrong"),
            _ => panic!("Expected text content"),
        }
    }
}
